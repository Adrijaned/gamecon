<?php

/**
 * Vrátí míru diverzifikace aktivit v poli udávajícím počty aktivit od jedno-
 * tlivých typů. Délka pole ovlivňuje výsledek (je potřeba aby obsahovalo i 0)
 */  
function aktivityDiverzifikace($poleTypu)
{
  $typu=count($poleTypu);
  $pocet=array_sum($poleTypu);
  $pocty=$poleTypu;
  rsort($pocty,SORT_NUMERIC);
  $max=($pocet-$pocty[0])/($pocet*($typu-1));
  $nPocty=array();
  for($i=1;$i<$typu;$i++)
  { //první počet přeskočit
    if($pocty[$i]/$pocet>$max)
      $nPocty[]=$max;
    else
      $nPocty[]=$pocty[$i]/$pocet;
  }
  return array_sum($nPocty)*$typu/($typu-1); //výsledná míra diverzifikace 0.0 - 1.0
}


/** Vrací datum ve stylu "pátek 14:00-18:00" na základě řádku db */
function datum2($dbRadek)
{
  if($dbRadek['zacatek'])
    return (new DateTimeCz($dbRadek['zacatek']))->format('l G:i').'–'.(new DateTimeCz($dbRadek['konec']))->format('G:i');
  else
    return '';
}


/** Vrací datum ve stylu 1. července 
 *  akceptuje vše, co žere strtotime */
function datum3($datum)
{
  $mesic=array('ledna', 'února', 'března', 'dubna', 'května', 'června',
    'července', 'srpna', 'září', 'října', 'listopadu', 'prosince');
  return date('j. ',strtotime($datum)).
    $mesic[date('n',strtotime($datum))-1];
}


/** Vrátí markdown textu daného hashe (cacheované, text musí být v DB) */
function dbMarkdown($hash) {
  if($hash == 0) return '';
  $out = kvs('markdown', $hash);
  if(!$out) {
    $text = dbOneCol('SELECT text FROM texty WHERE id = '.(int)$hash);
    if(!$text) throw new Exception('Text s daným ID se nenachází v databázi');
    $out = markdown($text);
  }
  return $out;
}


/** Načte / uloží hodnotu do key-value storage s daným názvem */
function kvs($nazev, $index, $hodnota = null) {
  if(!isset($GLOBALS['CACHEDB'][$nazev])) {
    $db = new SQLite3(SPECIFICKE.'/_cache_'.$nazev.'.sqlite');
    $GLOBALS['CACHEDB'][$nazev] = $db;
    $db->exec("create table if not exists kvs (k integer primary key, v text)");
  }
  $db = $GLOBALS['CACHEDB'][$nazev];
  if($hodnota === null) {
    // načítání
    $o = $db->query('select v from kvs where k = '.$index)->fetchArray(SQLITE3_NUM);
    if($o === false) return null;
    else return $o[0];
  } else {
    $db->exec('insert into kvs values('.$index.',\''.SQLite3::escapeString($hodnota).'\')');
  }
}


/**
 * Převede text na odpovídající html pomocí markdownu
 * @see Originální implementace markdownu je rychlejší jak Parsedown, ale díky
 *  cacheování je to jedno
 */
function markdown($text) {
  $hash = scrc32($text);
  $out = kvs('markdown', $hash);
  if($out === null) {
    kvs('markdown', $hash, markdownNoCache($text));
    $out = kvs('markdown', $hash);
  }
  return $out;
}


/** Převede text markdown na html (přímo on the fly) */
function markdownNoCache($text) {
  require_once(__DIR__.'/knihovny/old-hacked-markdown/markdown.php');
  $text = PlugMarkdown($text);
  $text = preg_replace_callback('@(p|h\d|strong|em|/)>[^<]+<@', function($m){
    $m[0] = str_replace('...', '…', $m[0]);
    $m[0] = str_replace(' - ', ' – ', $m[0]);
    return preg_replace('@"([^"]+)"@', '„$1“', $m[0]);
  }, $text);
  return $text;
}


/** Zjistí, jestli uživatel má volno v určitém časovém intervalu. (např. preve-
 *  nce kolizí aktivit nebo kolizí u orgů.
 *  @param array $poleCas pole s časovými údají odpovídajícími evidenci aktivit
 *  v databázi (den, zacatek jako od, konec jako do)
 *  @param int vyjimka ID akce, která se má vyjmout z hledání (typicky při editu
 *  akce testujeme kolizi ale nezajímá nás kolize "se sebou samou"  
 *  @return vrací true nebo false
 *  @todo tato operace by měla být řešena v rámci nějaké třídy speciální
 *  výjimkou, která ponese i seznam kolidujících aktivit v sobě.
 */
function maVolno($uid,$poleCas,$vyjimka=null)
{
  $GLOBALS['maVolnoKolizePole'] = array();      //pole kolizních aktivit
  if($uid===0 || $uid==='0') return true;       //"žádný" organizátor má vždy volno
  if(!$poleCas['zacatek']) return true;         //aktivita s neurčeným časem neblokuje
  if(ma_pravo($uid, P_KRYTI_AKCI)) return true; //aktivity se můžou krýt
  // nalezení aktivit a určení překrytí
  $a=dbQueryS('SELECT * FROM
      (SELECT a.* FROM akce_prihlaseni p
      JOIN akce_seznam a USING(id_akce)
      WHERE p.id_uzivatele=$0
      AND a.rok='.ROK.'
      UNION
      SELECT a.* FROM akce_seznam a
      JOIN akce_organizatori ao USING(id_akce)
      WHERE ao.id_uzivatele=$0
      AND a.rok='.ROK.') as a
    WHERE NOT (zacatek>=$2 OR konec<=$1) -- zacne az pak nebo skonci pred'."\n".
    ($vyjimka?'AND id_akce!=$3':''),
    array($uid, $poleCas['zacatek'], $poleCas['konec'], $vyjimka));
  if(mysql_num_rows($a))
  {
    while($r=mysql_fetch_assoc($a))
      $GLOBALS['maVolnoKolizePole'][]=$r;
    return false;
  }
  else
  {
    $GLOBALS['maVolnoKolizePole'][]=array();
    return true;
  }
}


/** Vrací pole kolizních aktivit posledního "maVolno" volání */
function maVolnoKolize()
{ 
  return isset($GLOBALS['maVolnoKolizePole'])?
    $GLOBALS['maVolnoKolizePole']:array();
}


/** Multibyte (utf-8) první písmeno velké */
function mb_ucfirst($string, $encoding=null)
{
  if(!$encoding) $encoding = mb_internal_encoding();
  $firstChar = mb_substr($string, 0, 1, $encoding);
  $then = mb_substr($string, 1, mb_strlen($string), $encoding);
  return mb_strtoupper($firstChar, $encoding) . $then;
}


/**
 * Kompiluje a minifikuje soubory předané v argumentech a vrací url s časovou
 * značkou (jako url proměnnou)
 * V složce soubory/perfectcache nutno (např. htaccessem) povolit cacheování
 * navždy
 * Poslední soubor slouží jako referenční k určení cesty, kam cache uložit
 */
function perfectcache($args) {
  $args = func_get_args();
  $lastf = end($args);
  $typ = substr($lastf, -3) == '.js' ? 'js' : 'css';
  $last = 0;
  foreach($args as $a) {
    $m = filemtime($a);
    if($last < $m) $last = $m;
  }
  $mind = substr($lastf, 0, strpos($lastf, '/')) . '/perfectcache';
  $minf = $mind . '/cache.' . $typ;
  $m = @filemtime($minf);
  // případná rekompilace
  if($m < $last) {
    if(!is_dir($mind)) mkdir($mind);
    if(is_file($minf)) unlink($minf);
    if($typ == 'js') {
      foreach($args as $a) file_put_contents($minf, file_get_contents($a), FILE_APPEND);
    } else {
      require_once(__DIR__.'/knihovny/less.php/Less.php');
      $parser = new Less_Parser(array('compress' => true));
      foreach($args as $a) $parser->parseFile($a);
      file_put_contents($minf, $parser->getCss());
    }
  }
  return $minf.'?v='.$last;
}


/** Tisk informace profileru. */
function profilInfo()
{
  if(VETEV == OSTRA)
    return false; //v ostré verzi se neprofiluje
  $schema = 'data:image/png;base64,';
  $iDb = $schema.base64_encode(file_get_contents(__DIR__.'/db.png'));
  $iHodiny = $schema.base64_encode(file_get_contents(__DIR__.'/hodiny.png'));
  //$iconRoot = URL_ADMIN.'/files/design/';
  $delka = microtime(true) - $GLOBALS['SKRIPT_ZACATEK'];
  // počet sekund, kdy už je skript pomalý (čas zčervená)
  $barva = $delka > 0.2 ? 'color:#f80;' : '';
  // výstup
  echo '
    <div class="profilInfo" style="
      background-color: rgba(0,192,255,0.80);
      color: #fff;
      bottom: 0;
      right: 0;
      position: fixed;
      padding: 2px 7px;
      cursor: default;
      z-index: 9999;
      border-top-left-radius: 4px;
      font: 13px Tahoma, sans-serif;
    ">
    <style>
      .profilInfo img { vertical-align: bottom; }
      @media (max-width: 480px) { .profilInfo { display: none; } }
    </style>
    <img src="'.$iHodiny.'" alt="délka skriptu včetně DB">
    <span style="'.$barva.'">'.round($delka*1000).'&thinsp;ms</span>
    &ensp; 
    <img src="'.$iDb.'" alt="délka odbavení DB/počet dotazů">
    '.round(dbExecTime()*1000).'&thinsp;ms ('.dbNumQ().' dotazů)
    </div>';
}


/**
 * Říká, zdali uživatel má určité právo identifikované číslem
 * @deprecated
 */
function ma_pravo($uzivatel,$cislo_prava)
{  

  //Ptáme se na práva aktuálně přihlášeného uživatele? Pokud ano, obejdeme DB
  $u=Uzivatel::zSession();
  if($u && $uzivatel==$u->id()) {
    return $u->maPravo($cislo_prava);
  }
  
  //Ptáme se obecně - načtení z DB
  if(isset($uzivatel) && $uzivatel)
  {
    $sql = "
      select
        uzivatele_zidle.id_zidle,
        uzivatele_zidle.id_uzivatele,
        prava_zidle.id_zidle,
        prava_zidle.id_prava
      from
        r_uzivatele_zidle uzivatele_zidle,
        r_prava_zidle prava_zidle
      where
        uzivatele_zidle.id_uzivatele = $uzivatel and
        uzivatele_zidle.id_zidle = prava_zidle.id_zidle and
        prava_zidle.id_prava = $cislo_prava";
        
      if(mysql_num_rows(dbQuery($sql))>0)
        return true;
      else
        return false;
  }
  return false;
}


/** Znaménkové crc32 chovající se stejně na 32bit i 64bit systémech */
function scrc32($data) {
  $crc = crc32($data);
  if($crc & 0x80000000){
    $crc ^= 0xffffffff;
    $crc += 1;
    $crc = -$crc;
  }
  return $crc;
}
